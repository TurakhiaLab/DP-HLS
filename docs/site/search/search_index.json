{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DP-HLS: A High-Level Synthesis Framework for Accelerating Dynamic Programming Algorithms in Bioinformatics","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the official wiki of DP-HLS. DP-HLS is a framework designed to simplify and accelerate the development of a broad set of bioinformatically relevant DP algorithms based on the 2-D DP paradigm using High-Level Synthesis (HLS). Built with the AMD Xilinx Vitis HLS tool, DP-HLS offers extensive customizability, enabling users to create and implement FPGA-accelerated kernels tailored to their specific applications.</p>"},{"location":"#2-d-dynamic-programming-paradigm","title":"2-D Dynamic Programming Paradigm","text":"<p>Many bioinformatics problems involve comparing linear biological sequences (DNA, RNA, proteins) to identify similarities and differences. A common approach to this problem is using 2-D dynamic programming (DP) algorithms (2-D DP paradigm), which typically consists of three steps: i) initialization, ii) matrix fill, and iii) traceback. </p> <p>The initialization step arranges the two sequences being compared on a 2-D grid, called DP matrix, with one sequence along the horizontal axis and the other along the vertical axis. The first row and column are initialized with predefined scores. Next, in the matrix fill step, a recursive formula is used to score each cell based on its three neighboring cells: above, left, and diagonal, allowing for \u2019gaps\u2019 in sequences. Finally, the traceback step, which is optional in some algorithms, recovers the path in the DP matrix corresponding to the sequence of decisions giving the overall optimal score. </p>"},{"location":"#variations-in-2-d-dynamic-programming-algorithms","title":"Variations in 2-D Dynamic Programming algorithms","text":"<p>Variations in general paradigm of 2-D Dynamic Programming has led to wide variety of algorithms used by bioinformatics tools in various applications. The table below lists some of the famous algorithms used in bioinformatics which is caused due to some variations in the scoring, initialization and traceback part of the general DP algorithmic template. These variations are described in Customize new kernels section below.</p>"},{"location":"#dp-hls-framework","title":"DP-HLS Framework","text":"<p>The DP-HLS framework is composed of two main components: the front-end and the back-end. The front-end component allows users to specify or customize new kernels in C/C++ by modifying certain parameters and code blocks. After configuring the HLS framework to create a kernel as per your usecases, then user needs to simulate, verify and synthesize the kernel. Once done, the kernel is ready to be deployed to FPGA after incorporating the host code. The above figure depicts the various stages of the front-end design flow. </p> <p>The back-end component of the DP-HLS framework contains a fixed set of HLS directives or pragmas that provide the HLS compiler with the necessary hints to efficiently map the front-end kernel design specification into an optimized RTL implementation  to be deployed to FPGA without requiring digital design expertise. </p>"},{"location":"#features","title":"Features","text":"<ol> <li>Easy customization of algorithms: HLS-based open-source framework streamlines the creation of FPGA accelerators for new algorithms. To implement any custom algorithm, only the scoring functions and a few parameters need to be modified without requiring an in-depth RTL or digital design experience.</li> <li>Easy deployment into hardware: The framework allows the user to implement highly customized FPGA kernels to deploy within days, whereas developing in HDL takes months.</li> <li>Supports complex 2-D DP based algorithms: DP-HLS supports the creation of Viterbi Algorithm, Multiple Sequence Alignment and Dynamic Time Warping Algorithm based kernels in a common framework for the first time. </li> <li>Faster kernels compared to baselines: DP-HLS based kernel implementation showed up to 32x improvements in throughput over CPU baselines and comparable results (within XX to XX margin) to hand-crafted RTL implementations, with the added benefit of easier design configurability.</li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To create, customize and deploy your own kernel on FPGA using DP-HLS framwork, it requires a series of steps to be executed. We have already developed pre-built templates of some of the well known algorithms listed in table 1. These pre-built templates are simulated using standard C++, synthesized using AMD Xilinx Vitis HLS 2022.1 toolchain on 8-core Amazon EC2 z1d instance and deployed on Amazon EC2 F1 instance based FPGA.</p> <p>The following sections mentions the steps to quickly simulate, synthesize and deploy global linear kernel which incorporates Needleman-Wunsch algorithm. Similar steps need to be followed for other pre-built kernel templates as well. To create and execute your own custom kernel, please refer to the sections which describes all possible commands and parameters supported by DP-HLS - Customize new kernels, Build and simulate new kernels and Synthesize and deploy new kernels. </p> <p>Step 0: Create AWS instances.</p> <p>To use our DP-HLS framework quickly to build and run the kernels, it would be preferrable to use AWS instances which comes with the AWS FPGA Developer AMI containing AMD Xilinx Vitis 2021.2. </p> <p>Step 1: Clone the DP-HLS repository from GitHub.</p> <p>The DP-HLS repo can be cloned using the following command: <pre><code>git clone https://github.com/TurakhiaLab/DP-HLS.git\n</code></pre> or <code>ssh</code> to : <pre><code>git@github.com:TurakhiaLab/DP-HLS.git\n</code></pre></p> <p>Step 2: Install the required dependencies.</p> <p>Please make sure the following dependencies are installed in your system.</p> <ul> <li>g++ &gt;= 4.8.5</li> <li>Python &gt; 3.6</li> </ul> <p>Step 3: Build and simulate the kernel.</p> <p>TBD</p> <p>Run the following command to build and simulate the kernel</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake &lt;target&gt; \n</code></pre> <p>Step 4: Synthesize and deploy the kernel on FPGA.</p> <p>TBD </p>"},{"location":"#customize-new-kernels","title":"Customize new kernels","text":"<p>This section mention detailed steps to create and customize your own kernel based on specific requirements. Once the kernels are customized, then it will be ready for simulation, synthesis and deployment. We also mention the details on how to build and simulate your kernel to verify the implementation in the section Build and simulate new kernels as well as how to synthesize and deploy it on AWS F1 FPGA instances (FPGA device in which we tested our pre-built kernel templates) in the section Synthesize and deploy new kernels.</p>"},{"location":"#step-1-understanding-variations-in-2-d-dynamic-programming-paradigm","title":"Step 1: Understanding variations in 2-D Dynamic Programming paradigm","text":"<p>Before starting, it is preferred to go through and understand the existing variations in 2-D DP paradigm before diving deep into the customization step. </p> <p>All kernels follow a general template for 2-D dynamic programming paradigm. However, subtle variations lead to creation of different types of algorithms for different usecases (check out algorithms and their corresponding variations listed in table 1). Some of the variations are mentioned in subsequent sections below. </p>"},{"location":"#variations-in-initialization-step","title":"Variations in Initialization Step","text":"<p>For the execution of dynamic progamming, the first row and column of the 2-D DP matrix needs to be initialized. User can provide their own initial scores for the first row and column depending on the usecases. Depending on which traceback strategy (described below) is used, the scores could be a constant (e.g., 0 or -\u221e) or a function of the gap penalties.</p>"},{"location":"#variations-in-traceback-step","title":"Variations in Traceback Step","text":"<p>Traceback step determine the path that results in the optimal score. While the recurrence scoring equations specify the optimal transitions on a path, depending on the usecases, the traceback strategy determines where to start and end the traceback path. There are variations seen in the traceback step for mainly four categories of alignments algorithms: global, local, semi-global, and overlap. User can have their own traceback strategy depending on their requirements. </p> <ol> <li>Global strategy performs end-to-end comparison of sequences, with traceback starting from the bottom-right cell of the 2-D DP matrix to the top-left cell. This is commonly used when two corresponding sequences, e.g., gene sequences, are being compared. </li> <li>Local strategy finds the most similar subsequences and is ideally suited for identifying conserved motifs or functional regions in sequences. Here, the traceback begins from the highest-scoring cell and stops at a 0-scoring cell.</li> <li>Semi-global strategy allows paths spanning one sequence end-to-end with a sub-sequence of the other. Here, the traceback begins from the highest-scoring cell in the bottom row of the 2-D DP matrix and continues to the top row. </li> <li>Overlap strategy matches sub-sequences at the beginning of one sequence and at the end of the other. This algorithm finds applications in genome assembly. Here, the traceback starts from the highest-scoring cell in the rightmost column (bottom row) of the 2-D DP matrix and continues to the top row (leftmost column).</li> </ol>"},{"location":"#variations-in-scoring-logic","title":"Variations in Scoring Logic","text":"<p>Scoring of the cells in the 2-D DP paradigm refers to the recurrence equations used to calculate the individual scores of cells in the 2-D grid. Equations reward matches or similarities of characters in the two sequences being compared and penalize mismatches or gaps. Several variations of scoring strategies are commonly used in bioinformatics applications as shown in the above figure. User can specify their own scoring equation for their custom algorithmic requirement. </p>"},{"location":"#variations-in-input-alphabets","title":"Variations in Input Alphabets","text":"<p>An alphabet refers to the set of characters used to represent the sequences being compared, such as DNA, RNA, or protein sequences, which consists of 4 or 20 characters, although variations may exist. In DNA based kernel algorithms, sequences are represented as 4 different nucleotides, with extra N representing the ambiguous bases. Multiple sequence alignment inputs are represented as profiles which is a tuple of 5 (21) integers, referring to the frequencies of 4 nucleotides. For RNA based alignments, inputs alphabets are represented as 20 different characters corresponding to amino acids. Dynamic Time Warping based alignments, used in signal processing to compare two time-series signals, uses real or complex number values as input alphabets. </p> <p>Hence for different types of algorithms, there can be differences in types of input alphabets and their representation, provided by the user. </p>"},{"location":"#step-2-customize-data-types-and-parameters","title":"Step 2: Customize data types and parameters","text":"<p>Step 2-6 describes how to configure and customize your own kernel. The customization steps involve changes in few parameters as well as addition/modification of few code blocks as mentioned. Once you are aware of the variations that exists and how it leads to different algorithms (described in step 1), it will be easier to configure parameters. </p> <p>DP-HLS framework supports custom data types of all kernels with variable precision for scoring, traceback, and internal logic indices. This flexibility enables users to attain optimal computational efficiency according to the specific needs of their kernels. </p> <p>The possible datatype and parameter customization supported by DP-HLS is described in this step below.</p>"},{"location":"#1-modify-sequence-alphabet","title":"1. Modify Sequence Alphabet","text":"<p>To modify the sequence alphabets of the inputs of custom kernels, define an arbitrary user-defined datatype <code>char_t</code> as follows. The example mentions a 2-bit precision integer used to define char_t. This alphabet represents the four nucleotide bases <code>A</code>,<code>C</code>,<code>G</code>,<code>T</code> within the custom kernels requiring DNA sequences as input. </p> <pre><code>typedef ap_uint&lt;2&gt; char_t;\n</code></pre> <p>To define input alphabets for Dynamic Time Warping (DTW) kernels, DP-HLS requires user to define a struct (shown below) consisting of two 32-bit fixed-point numbers to represent the real and imaginary parts of the two temporal signals (which take complex values) being compared by the kernel.</p> <pre><code>struct char_t_st {\n    ap_fixed &lt;32,26&gt; real, imag;\n    };\n\ntypedef char_t_st char_t \n</code></pre>"},{"location":"#2-modify-scoring-layers","title":"2. Modify Scoring Layers","text":"<p>To design and customize a 2-D DP kernel that involves multiple recurrence equations, each computing a unique value per cell, DP-HLS provides a variable called <code>N_LAYERS</code> which configures the number of unique values computed and stored per cell of the DP matrix. </p> <p>For example, for affine-gap penalty based kernels, which uses 3 recurrence equations, <code>N_LAYERS</code> is set to 3. For two-level affine-gap penalty based kernels, set it to 5 for 5 layers of DP-matrix, each governed by one recurrence equation. </p>"},{"location":"#3-modify-scoring-parameters","title":"3. Modify Scoring Parameters","text":"<p>For a custom kernel, specify arbitrary number of scoring parameters used by the kernels, each of arbitrary data types in a C/C++ struct called <code>ScoringParams</code>. The following example shows the definition of <code>ScoringParams</code> for Global Linear Kernel which uses 3 parameters: match, mismatch and one linear gap penalty. </p> <pre><code>struct ScoringParams { \n    type_t mismatch;\n    type_t match;\n    type_t linear_gap;\n} params;\n</code></pre> <p>Viterbi algorithm for pairHMMs requires three hidden states (M-Match/Mismatch, I-Insertion and D-Deletion) and a total of 27 parameters including two transition probabilities between three hidden states and 5x5 matrix storing the emission probabilities for all pairs of character (<code>A</code>,<code>C</code>,<code>G</code>,<code>T</code>) in the M states. The following example illustrates the definition of struct <code>ScoringParams</code> used for designing Viterbi Algorithm. </p> <pre><code>struct ScoringParams {\n    type_t log_mu ;\n    type_t log_lambda ;\n    type_t emission [5][5];\n} params ;\n</code></pre>"},{"location":"#4-specify-maximum-sequence-lengths","title":"4. Specify Maximum Sequence Lengths","text":"<p>DP-HLS requires users to set the maximum sequence lengths for the input reference and query using <code>MAX_REFERENCE_LENGTH</code> and <code>MAX_QUERY_LENGTH</code> to determine the memory sizes for storing sequences and traceback pointers on the FPGA device. This allows user to execute kernels with sequence lengths smaller than or equal to maximum configured lengths without reimplementing the kernel. </p>"},{"location":"#5-specify-traceback-pointer-data-types-and-states","title":"5. Specify Traceback Pointer data types and states","text":"<p>To specify the datatype for traceback pointers, define the datatype <code>tb_t</code> as arbitrary precision integers (<code>ap_uint&lt;2&gt;</code> for Global Linear Kernel and <code>ap_uint&lt;4&gt;</code> for Global Affine Kernel since both kernels require a 2-bit and 4-bit traceback pointer, respectively). 2-bit traceback pointer is used to point any one position out of 3 positions (up, left and diagonal) for each of the cell. Among 4-bit traceback pointer used by Global Affine, 2-bit is used for direction mentioned above. Upper 2 bits are used for choosing one layer out of three layers in affine gap penalty based kernels. </p> <p>The traceback logic in the final step of DP algorithms is equivalent to a finite state machine (FSM) in which the current state <code>tb_curr_state</code> and the traceback matrix determine the next state <code>tb_next_state</code>, and the state transitions translate to the traceback path. The users are required to enumerate the possible traceback states in the variable <code>TB_STATE</code> as shown below.</p> <p>The following example enumerates three states \u2014 <code>MM</code>, <code>INS</code>, and <code>DEL</code> \u2014 in the Global Linear kernel representing the three possible states of traceback pointers based on its recurrence equation.</p> <pre><code>enum TB_STATE {\n    MM , INS , DEL\n} tb_next_state, tb_curr_state ;\n</code></pre> <p>The following example shows for the Global Affine kernel, where the two additional recurrence equations for long gap scores <code>LONG_INS</code> and <code>LONG_DEL</code> (long deletion and long insertion respectively) each add a traceback state. </p> <pre><code>enum TB_STATE {\n    MM , INS , DEL ,\n    LONG_INS , LONG_DEL\n} tb_next_state, tb_curr_state ;\n</code></pre>"},{"location":"#6-specify-band-width-for-banding-kernels","title":"6. Specify Band Width (for banding kernels)","text":"<p>DP-HLS allows user to opt the banding search space pruning strategy in their custom kernel by setting the macro <code>BANDING</code> to <code>FIXED</code> and <code>BANDWIDTH</code> to the desired band size. <code>BANDING</code> is set to <code>RECTANGULAR</code> by default or if no banding is needed.</p>"},{"location":"#step-3-initialize-row-and-column-scores","title":"Step 3: Initialize row and column scores","text":"<p>Once the parameters are specified based on requirements (described in step 2), now its time to add/modify code blocks for initialization, scoring and traceback logic for your own custom kernel. This step shows how to add your own column and row initialization scores as the first step in the 2-D DP paradigm. </p> <p>To provide the initial row and column scores to the custom kernel for the initial step, specify the values of the 2-D arrays <code>init_row_scr</code> and <code>init_col_scr</code>. Each array is of dimensions <code>MAX_REFERENCE_LENGTH \u00d7 N_LAYERS</code> and <code>MAX_QUERY_LENGTH \u00d7 N_LAYERS</code>, respectively. The users should only specify the values of these arrays, as the DP-HLS\u2019s back-end automatically copies them to the device at runtime.</p> <p>The following example illustrates the row and column initialization of Global Linear Kernel. It has a single scoring layer at index 0 whose first row and column are initialized to account for gaps at the start of the alignment.</p> <pre><code>type_t gap = scoring_params . linear_gap ;\nfor ( int i = 0; i &lt; MAX_REFERENCE_LENGTH ; i ++) {\n    init_row_scr [ i ][0] = i * gap ; }\nfor ( int i = 0; i &lt; MAX_QUERY_LENGTH ; i ++) {\n    init_col_scr [ i ][0] = i * gap ; }\n</code></pre>"},{"location":"#step-4-specify-scoring-function","title":"Step 4: Specify Scoring function","text":"<p>The second step after initialization is the scoring of the DP matrix. To execute this step, user needs to provide their own recurrence equations to be executed by each Processing Elements (PE) and filled up in each of the cells of the DP matrix. </p> <p>Specify the recurrence equations for computing the score and traceback pointer for a single cell (i, j), located at row i and column j of the DP matrix, in a specific function, <code>PE_func</code>. </p> <p>The following example code shows the scoring equations computed by PEs for the Local Linear kernel. The arrays <code>dp_mem_up</code>, <code>dp_mem_diag</code>, and <code>dp_mem_left</code>, are the inputs to <code>PE_func</code> and populated with cell scores automatically by the DP-HLS backend for cells at positions up (i-1, j), diagonal (i-1, j-1) and left (i, j-1) of the current cell (i, j). Likewise, the i\ud835\udc61h query character and the j\ud835\udc61\u210e reference character are also automatically available to the input of <code>PE_func</code> as <code>lc_qry_val</code> and <code>lc_ref_val</code>, respectively. At the end of the function call, valid scores and traceback pointers for cell (i, j) must be stored to <code>wt_scr</code> and <code>wt_tbp</code>.</p> <pre><code>// Inside Local Linear PE_func\n// Compute the upper , left , and diagonal scores\n\ntype_t linear_gap = params . linear_gap ;\ntype_t ins = dp_mem_left [0] + linear_gap ;\ntype_t del = dp_mem_up [0] + linear_gap ;\ntype_t match = dp_mem_diag [0] + ( lc_qry_val == lc_ref_val ) ? params . match : params . mismatch ;\n</code></pre> <pre><code>// determine the maximum value and traceback\n\ntype_t max_value = ins ;\nwt_tbp = TB_LEFT ;\n\nif ( max_value &lt; match ) { max_value = match ;\n    wt_tbp = TB_DIAG ; \n    }\nif ( max_value &lt; del ) { max_value = del ;\n    wt_tbp = TB_UP ; \n    }\nif ( max_value &lt; ( type_t ) 0) { max_value = 0;\n    wt_tbp = TB_END ; \n    }\n\nwt_scr = max_value ;\n</code></pre>"},{"location":"#step-5-specify-traceback-strategy","title":"Step 5: Specify Traceback Strategy","text":"<p>The third step after initialization and scoring logic modification of your own custom kernel is to specify the traceback logic/strategy.</p> <p>Each score matrix cell is mapped to a state, and state transitions correspond to jumps between scoring matrices. User needs to define the logic to map the current cell\u2019s state and its traceback pointer to the next cell which is called at every traceback step. </p> <p>In the Local Linear kernel example with a single state shown below, the outer if-statement checks the current state from the <code>tb_state</code> and assigns the new state. The traceback write-out port <code>wt_tbp</code> is assigned a direction to move in the score matrix, corresponding to insertion, deletion, match/mismatch, or end of the traceback.</p> <pre><code>if ( tb_state == TB_STATE :: MM ) {\n    if ( tb_ptr == TB_DIAG ) { tb_move = AL_MMI ; \n    }\n    else if ( tb_ptr == TB_UP ) { tb_move = AL_DEL ; \n    }\n    else if ( tb_ptr    == TB_LEFT ) { tb_move = AL_INS ;\n    }\n    else if ( tb_ptr == TB_END ) { tb_move = AL_END ;\n    }\n    else { tb_move = AL_END ; \n    }\n\ntb_state = TB_STATE :: MM ;\n}\n</code></pre>"},{"location":"#step-6-specify-parallelism","title":"Step 6: Specify Parallelism","text":"<p>Each kernel in DP-HLS consists of NB blocks, which concurrently execute distinct pairs of input sequences, each having NPE number of PEs. These blocks are identical in terms of hardware implementation, ensuring uniform performance across all blocks. To exploit the resources for maximum throughput, DP-HLS allows multiple blocks to be executed in single hardware device. DP-HLS also allows user to integrate and execute different types of kernels (Nk number of heterogenous kernels), each having NB blocks. </p> <p>The parameter NPE determines the level of inner-loop parallelism for a single pair of sequences. DP-HLS also exploits outer-loop parallelism across multiple sequence pairs by setting the parameters NB and NK.</p> <p>The values of NPE, NB and NK are all customizable by the users. </p>"},{"location":"#build-and-simulate-new-kernels","title":"Build and simulate new kernels","text":"<p>Once the kernels are customized based on your own specific requirement, then its time to build and simulate it to verify the changes. The C-Simulation or C based simulation of the customized kernel is performed with CMake, since it enables standard C++ debugging processes and the debuggers. </p> <p>Note</p> <p>Vitis HLS also supports the C-Simulation step which uses <code>v++</code> compiler. However, we found the standard <code>c++</code> compiler to have much smaller latency in rebuilding the kernel and rerun the debugger than using the Vitis HLS.</p>"},{"location":"#step-1-install-dependencies","title":"Step 1: Install Dependencies","text":"<p>To build and simulate the kernel, it is required to have <code>g++ (GCC) &gt;= 4.8.5</code> and <code>CMake3</code> installed in your system. </p> <p>Note</p> <p>If you have older version of CMake in your system, you need to install CMake3 and set it to default instead. You could follow this useful StackOverflow post to perform this step.</p>"},{"location":"#step-2-create-a-testbench","title":"Step 2: Create a testbench","text":"<p>For the basic C based simulation of the customized kernel, user needs to create a simple testbench to drive the kernel at this step. A testbench should consists of:</p> <p>TBD</p> <p>Following shows an example of a testbench for global affine kernel. You can create our own testbench by following this example. </p> <p>TBD</p> <p>Note</p> <p>This testbench is for the purpose of C simulation only and is different from the OpenCL Host program mentioned later which is needed for the actual deployment of the kernel on FPGA.</p>"},{"location":"#step-3-build-and-run","title":"Step 3: Build and Run","text":"<p>Once dependencies are installed, you need to edit the <code>CMakeLists.txt</code> provided in the GitHub repository for your own kernel target. </p> <p>For each target, you need to add the lines specifying the following:</p> <ol> <li>Common source file - <code>COMMON_SRCS</code> that is required for all the kernels. </li> <li>Testbench file. </li> <li>User defined function source. </li> </ol> <p>Then you need to add the folder containing <code>params.h</code> as a include path for your kernel. The following example shows how it should be done for global affine kernel. These lines need to be added in the <code>CMakeLists.txt</code>. Similarly, you need to do it for your own custom kernel. </p> <pre><code>add_executable(test_csim_global_affine\n    \"testbench/test_csim_global_affine.cpp\"\n    \"kernels/global_affine/kernel_global_affine.cpp\"\n    ${COMMON_SRCS})\n\ntarget_include_directories(test_csim_global_affine PRIVATE \"./kernels/global_affine\")\n</code></pre> <p>Once the <code>CMakeLists.txt</code> is configured, follow the below commands to build and run the target (i.e, your own custom kernel).</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake &lt;target&gt; ## here the target is the kernel found in the CMakeLists.txt\n</code></pre> <p>Note</p> <p>With the CMake extension, VSCode automatically detect and configure the CMake project with the <code>CMakeLists.txt</code> provided in the repo. You can simply use the VSCode CMake extension GUI to build and run the project. </p> <p>Note</p> <p>Kernels in DP-HLS framework are tested on CentOS7 with AMD Xilinx Vitis 2021.2, the OS and toolchain which comes with the AWS FPGA Developer AMI. We would suggest this platform to build and run the DP-HLS kernels because it comes with the device license in AMD Xilinx Vitis and Vivado for the FPGA device on AWS F1 instances. </p> <p>If you are not using the specified AMI, then you need to set the <code>HLS_HOME</code> variable in <code>CMakeLists.txt</code> to point to the customized Vitis HLS installation path so CMake can find the correct include and link path. </p>"},{"location":"#synthesize-and-deploy-new-kernels","title":"Synthesize and deploy new kernels","text":""},{"location":"#step-1-write-host-side-program","title":"Step 1: Write host-side program","text":"<p>In addition to the <code>params.h</code> and your kernel function source file, you need to write a OpenCL host program to synthesize and deploy the kernel. A simple example for the host program can be found in the Vitis Examples.</p> <p>Following example shows a host program for a global affine kernel.</p> <p>TBD</p>"},{"location":"#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<p>We have provided some scripts to run the synthesis and cosimulation of the kernels. For that, you need to have <code>Python: Version &gt; 3.6</code> installed in your system. </p> <p>Kernels in DP-HLS framework are tested on CentOS7 with AMD Xilinx Vitis 2021.2, the OS and toolchain which comes with the AWS FPGA Developer AMI.  You can use any AWS machine to synthesis the kernel as long as it's compatible with the FPGA developer AMI. We used 8-core Amazon EC2 z1d instances for the implementation of DP-HLS kernel.</p>"},{"location":"#step-3-configure-the-project-using-json-file","title":"Step 3: Configure the project using JSON file","text":"<p>We provide a set of Python scripts with the DP-HLS repository to streamline the AMD Xilinx Vitis HLS project creation, synthesis, and implementation. Those scripts are in the <code>py-hls</code> folder. </p> <p>Those scripts require JSON configuration file as input. Following example shows how to configure the JSON file with the explanation of all parameters. This JSON file below has prefilled parameters for the global affine kernel. Similarly, you need to do it for your own custom kernel.</p> <pre><code>{\n    \"size\": {\n        \"max_problem_size\": [\n            {\"max_query_length\": 256, \"max_reference_length\": 256}\n        ],\n        \"pe_num\": [4, 8, 16, 32],\n        \"blocks\": [1],\n        \"cu\": [1]\n    },\n    \"kernel\": {\n        \"name\": \"seq_align_multiple_static\",\n        \"clock_frequency\": 250000000\n    },\n    \"design\": {\n        \"path_params\": \"/home/centos/workspace/DP-HLS/compile_configs/global_affine/design\",\n        \"path_frontend\": \"/home/centos/workspace/DP-HLS/compile_configs/global_affine/design/kernel_global_affine.cpp\",\n        \"dp-hls_root\": \"/home/centos/workspace/DP-HLS\",\n        \"host_program\": \"/home/centos/workspace/DP-HLS/src/hosts/host_ocl_global.cpp\"\n    },\n    \"output_path\": \"/home/centos/workspace/DP-HLS/synthesis/results/global_affine\",\n    \"output_name\": \"global_affine_inlined\",\n    \"build\": {\n        \"build_type\": \"hw\"\n    },\n    \"vitis_hls\": {\n        \"cosim_testbench\": \"/home/centos/workspace/DP-HLS/testbench/test_csim_global_affine.cpp\",\n        \"output_path\": \"/home/centos/workspace/DP-HLS/vitis_projects/global_affine\",\n        \"export_design\": 0\n    }\n}\n</code></pre>"},{"location":"#json-parameters-explained","title":"JSON Parameters Explained","text":"<ul> <li><code>size</code>: Related to the size of the kernel. <ul> <li><code>max_problem_size</code>: Defines the <code>MAX_QUERY_LENGTH</code> and <code>MAX_REFERENCE_LENGTH</code>. </li> <li><code>pe_num</code>: Number of PE in a block. </li> <li><code>blocks</code>: Number of blocks in a kernel. </li> <li><code>cu</code>: Number of compute units linked in a FPGA bitsteram. </li> </ul> </li> <li><code>kernel</code>: Related to the kernel name and clock frequency. <ul> <li><code>name</code>: This sets the name of your custom kernel. Currently the name <code>seq_align_mulitple_static</code> is supported. </li> <li><code>clock_frequency</code>: This sets the target clock frequency. If the design can't meet this clock frequency, then it will be lowered automatically in the kernel linking stage.</li> </ul> </li> <li><code>design</code>:<ul> <li><code>path_params</code>: Specifies the path to the folder containing the <code>params.h</code>. </li> <li><code>path_frontend</code>: Specifies the path to the front-end kernel source file. In this case, it points to <code>kernel_global_affine.cpp</code>.</li> <li><code>dp-hls_root</code>: Defines the root directory of the DP-HLS library. </li> <li><code>host_program</code>: Points to the source file of the OpenCL host program that manages kernel execution on the FPGA.</li> </ul> </li> <li><code>output_path</code>: Specifies the output directory for generated RTL code, reports, and log files. </li> <li><code>output_name</code>: Defines the base name for the output files generated during the synthesis process. In this example, the output files will be prefixed with <code>global_affine_inlined</code>.</li> <li><code>build</code>: Related to the build configuration for the Vitis project. The <code>build_type</code> can be <code>sw_emu</code>, <code>hw_emu</code>, or <code>hw</code> which is equivalent to the three <code>TARGETS</code> described in the <code>aws-fpga</code> repo. </li> <li><code>vitis_hls</code>: Contains settings specific to using the Vitis HLS toolchain.<ul> <li><code>cosim_testbench</code>: Specifies the path to the C++ testbench file used for co-simulation.</li> <li><code>output_path</code>: Indicates the output directory of the Vitis HLS project. This is separate from the bitstream output path specified in the <code>output_path</code> above. </li> <li><code>export_design</code>: A flag indicating whether the design should be exported after synthesis. A value of <code>0</code> means the design will not be exported, while <code>1</code> would run the implementation and gives the post-route utilization number.</li> </ul> </li> </ul> <p>With the JSON config file above, you can compile a batch of kernels with the full combinations of <code>max_problem_size</code> x <code>pe_num</code> x <code>blocks</code> x <code>kernels</code> with the naming convention <code>&lt;name&gt;_&lt;max_query_length&gt;_&lt;max_reference_length&gt;_&lt;pe_num&gt;_&lt;blocks&gt;_&lt;kernels&gt;</code> in the output directory. For example, if the <code>size</code> is:  <pre><code>\"size\": {\n    \"max_problem_size\": [\n        {\"max_query_length\": 256, \"max_reference_length\": 256}\n    ],\n    \"pe_num\": [16, 32],\n    \"blocks\": [8, 16],\n    \"cu\": [1]\n}\n</code></pre> Then the output director would contains the following folders, each one containing everything compile-related for that specific kernel configuration: <pre><code>output_dir/                      \n\u251c\u2500\u2500 global_affine_256_256_16_8_1\n\u251c\u2500\u2500 global_affine_256_256_16_16_1\n\u251c\u2500\u2500 global_affine_256_256_32_8_1\n\u2514\u2500\u2500 global_affine_256_256_32_16_1\n</code></pre></p>"},{"location":"#step-4-synthesize-the-kernel","title":"Step 4: Synthesize the kernel","text":"<p>To run the python script which streamline the AMD Xilinx Vitis HLS project creation, synthesis, and implementations, run the following command:</p> <pre><code>python py-hls/auto_cosim.py --config &lt;path_to_the_json_config&gt; --simulate True\n</code></pre>"},{"location":"#explaining-command-line-arguments","title":"Explaining command-line arguments","text":"<ul> <li><code>--config</code>: Specify the path of the configured JSON file</li> <li><code>--simulate</code>: Set to <code>True</code> if you need to perform the co-simulation step along with the synthesis step of the Vitis HLS design flow. Set to <code>False</code> if only synthesis step is needed to be performed.</li> </ul>"},{"location":"#step-4-analyze-the-implementation-output","title":"Step 4: Analyze the implementation output","text":"<p>After executing the python script which perform synthesis and co-simulation step of the Vitis HLS design flow, several output files will be created. Following shows the file structure for all the output files saved in the output directory for the global affine kernel (some non-essential files are not shown here). <pre><code>output_dir/                      \n\u251c\u2500\u2500 global_affine_256_256_16_8_1/                 \n\u2502   \u251c\u2500\u2500 _x.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3/\n\u2502   \u251c\u2500\u2500 build_dir.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3/\n\u2502   \u251c\u2500\u2500 report/  \n|   \u251c\u2500\u2500 dp-hls-host\n|   \u251c\u2500\u2500 Makefile\n|   \u251c\u2500\u2500 parallel_compile_error.log         \n\u2502   \u2514\u2500\u2500 parallel_compile_output.log\n\u251c\u2500\u2500 global_affine_256_256_16_16_1\n\u251c\u2500\u2500 global_affine_256_256_32_8_1\n\u2514\u2500\u2500 global_affine_256_256_32_16_1\n</code></pre></p>"},{"location":"#details-of-the-output-files-generated","title":"Details of the output files generated","text":"<ul> <li><code>build_dir.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3</code> contains the output <code>.xclbin</code> bitstream file, which later on needed to be used to create the AFI. </li> <li>Detailed synthesis and implementation report (place and route) as well as the logs can be found under <code>_x.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3</code>.<ul> <li>Detailed Synthesis Report found in: <code>_x.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3/seq_align_kernel/seq_align_multiple_static/seq_align_multiple_static/solution/syn/report</code></li> <li>Synthesized Verilog source file found in: <code>_x.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3/seq_align_kernel/seq_align_multiple_static/seq_align_multiple_static/solution/impl/verilog</code></li> <li>Logs found in: <code>_x.hw.xilinx_aws-vu9p-f1_shell-v04261818_201920_3/logs</code></li> </ul> </li> <li><code>report</code> folder contains synthesis and place and route summary. </li> <li><code>Makefile</code> contains the the original make file used to compile the kernel. </li> <li><code>parallel_compile_error.log</code> contains the compile error collected from the <code>stderr</code> for this specific kernel. </li> <li><code>parallel_compile_output.log</code> contains the compile output collected from the <code>stdout</code> for this specific kernel. </li> </ul>"},{"location":"#analyze-the-output-using-gui","title":"Analyze the output using GUI","text":"<p>To inspect the reports of Vitis HLS Co-Simulation and Implementation visually using GUI, please open Vitis HLS GUI and select \"open project\" to open the folder <code>global_affine_256_256_16_8_1</code> under the path specified for <code>vitis_hls/output_path</code> in the config (different from the compile output path). </p> <p>TBD</p>"},{"location":"#step-5-generate-the-bitstream","title":"Step 5: Generate the bitstream","text":"<p>Once the kernel is synthesized and co-simulated, run the following command to generate the bitstream:  <pre><code>python py-hls/parallel_compile.py --config &lt;path_to_the_json_config&gt; --compile True --num_workers &lt;workers&gt; --all True\n</code></pre> The flags for this script is explained below: </p> <ul> <li><code>config</code>: Specify the path to the JSON configuration file mentioned above.</li> <li><code>compile</code>: Specify whether to compile the project or not. If set to <code>False</code>, only the Makefile is created. </li> <li><code>num_workers</code>: Specify the number of parallel compilation jobs when compiling for a batch of different kernel configs. The number depends on the available device resources. Too many parallel jobs would result in some kernel's compilation killed. </li> <li><code>all</code>: Specify whether to compile everything for the kernel or not, including the host and the kernel. If set to <code>False</code>, then only the host is compiled. If set to <code>True</code>, then both host and kernel is compiled.</li> </ul> <p>Note</p> <p>The compilation could take very long time, and you can verify the progress of the kernel compilation by inspecting the <code>v++</code> log file. Normally the compilation are put to the background, <code>tmux</code> perferrably. </p>"},{"location":"#step-6-deploy-the-kernel-on-aws-f1-fpga","title":"Step 6: Deploy the kernel on AWS F1 FPGA","text":"<p>With the <code>.xclbin</code> bitstream file generated and the host program written (mentioned in step 1), your custom kernel is now ready to be deployed. </p> <p>If the custom kernels' bitstream and the host program are built on another system/AWS instance other than AWS F1 FPGA instance, you can share those files with the AWS F1 instance through EFS. </p> <p>Once the bitstream is available on AWS F1 FPGA instance, follow the following steps for the deployment. This standard process is also well described in the Step 2 in Vitis Section of the AWS FPGA repo. </p> <ol> <li>Create an F1 instance with the AWS FPGA Developer AMI. </li> <li>Create AFI then wait until it's status is ready. </li> <li>Run the kernel by calling the OpenCL host and pass-in the <code>.awsxclbin</code> bitstream. </li> </ol>"},{"location":"#source-code-documentation","title":"Source Code Documentation","text":"<p>To refer to the details of the source code for using the DP-HLS framework efficiently, please refer to Source Code Documentation</p>"},{"location":"#contributions","title":"Contributions","text":"<p>We welcome contributions from the community. If you encounter any issues or have suggestions for improvement, please open an issue on GitHub. For general inquiries and support, reach out to our team.</p>"},{"location":"#citing-dp-hls","title":"Citing DP-HLS","text":"<p>If you use DP-HLS in your research or publications, please cite the following paper:</p>"}]}